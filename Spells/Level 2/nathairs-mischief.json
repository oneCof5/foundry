{
  "flags": {
    "itemacro": {
      "macro": {
        "data": {
          "name": "Nathairâ€™s Mischief",
          "type": "script",
          "scope": "global",
          "command": "/*\nThis code implements Nathair's Mischief for DnD5e\n\nNotes:\n- I'd like to check for the molasses image instead of assume it's there, but I couldn't get that to work.\n\n*/;\n\nconsole.clear();\nconsole.log(\"Begin Nathair's Mischief\");\nasync function wait(ms) { return new Promise(resolve => { setTimeout(resolve, ms); }); }\n\n//***********************  Delete template from previous round and set color of new template   *************************;\n\n// Get list of template IDs. This is only used for debugging.;\nlet templateIds = canvas.templates.placeables.filter(t => t.data.user === game.user.id).map(t => t.id);\nconsole.log(templateIds);\n// Get list of placed templates;\nlet placeables = canvas.templates.placeables.filter(t => t.data.user === game.user.id);\nconsole.log(placeables);\n// Get template placed from casting spell;\nlet lastPlaceable = placeables[placeables.length-1];\nlet lastPlaceableID = lastPlaceable.id;\n\n// Look for previous Mischievous Surge terrain(s) and delete them;\nlet msIDs = placeables.filter(t => t.data.fillColor === `#5f2ea3` && t.id != lastPlaceableID).map(t => t.id);\nconsole.log(\"msID: \");\nconsole.log(msIDs);\nif (msIDs.length > 0) {\n     console.log(\"Old terrains found.\");\n\t for (let msID of msIDs) {\n     await canvas.scene.deleteEmbeddedDocuments(\"MeasuredTemplate\",[msID]);\n\t };\n};\n\n// Adjust color ;\nawait lastPlaceable.document.update({fillColor:`#5f2ea3`})\nawait lastPlaceable.document.update({borderColor:`#000000`})\n// Refresh the template to apply changes;\nawait lastPlaceable.refresh();\n\nconsole.log(`Color changes`);\nconsole.log(lastPlaceable);\n\n//************************ Roll the Mischief Surge table and set conditions appropriately ******************************;\n\nconst lastArg = args[args.length - 1];\nconsole.log(game.tables);\nconst roll = await game.tables.getName(\"Nathair's Mischief: Mischievous Surge\").roll();\nconsole.log(roll);\nconst rollvalue = roll.roll._total;\nconsole.log(\"Value: \" + rollvalue);\nconst rolltxt = roll.results[0].data.text; \nconsole.log(\"Name: \" + rolltxt);\nconst chatData = { \n    user: game.user.id, \n    speaker: ChatMessage.getSpeaker(), \n    content: rolltxt, \n    whisper: ChatMessage.getWhisperRecipients(\"GM\") \n};\nChatMessage.create(chatData);\n\nlet saveType;\nlet effectType;\nlet effectData;\nlet gameRound;\n  \nif (rollvalue == 4) {\n\t// Change template texture to molasses;\n\tawait lastPlaceable.document.update({texture:`molasses.jpg`});\n\t//**************  Change to difficult terrain ************************;\n\t// Intermediate steps because dealing with names that include hyphens is a pain in the ass.;\n\tlet flags= lastPlaceable.document.data.flags;\n\tlet etl= flags[\"enhanced-terrain-layer\"];\n\tconsole.log(\"Multiple before: \" + etl.multiple);\n\t// Set terrain cost multiple and confirm\n\tawait lastPlaceable.document.setFlag(\"enhanced-terrain-layer\", \"multiple\", 2)\n\tflags= lastPlaceable.document.data.flags;\n\tetl= flags[\"enhanced-terrain-layer\"];\n\tconsole.log(\"Multiple after: \" + etl.multiple);\n\t// Refresh the template to apply changes;\n\tawait lastPlaceable.refresh();\n\treturn;\n};\nif (rollvalue == 1) {\n\tsaveType = \"wis\";\n\teffectType=\"charmed\";\n\teffectData = {\n\t\tlabel: \"Charmed\",\n\t\ticon: \"modules/combat-utility-belt/icons/charmed.svg\",\n\t\tflags: { dae: { macroRepeat: \"none\", specialDuration: [\"turnStartSource\"] } },\n\t\torigin: lastArg.uuid,\n\t\tdisabled: false,\n\t\tduration: {seconds: 12, rounds: 1, turns: 1, startRound: gameRound, startTime: game.time.worldTime }\n\t};\n};\nif (rollvalue == 2) {\n\tsaveType = \"dex\";\n\teffectType=\"blinded\";\n\teffectData = {\n\t\tlabel: \"Blinded\",\n\t\ticon: \"icons/svg/blind.svg\",\n\t\tflags: { dae: { macroRepeat: \"none\", specialDuration: [\"turnStartSource\"] } },\n\t\torigin: lastArg.uuid,\n\t\tdisabled: false,\n\t\tduration: {seconds: 12, rounds: 1, turns: 1, startRound: gameRound, startTime: game.time.worldTime },\n\t\tchanges: [{ key: `flags.midi-qol.grants.advantage.attack.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 },\n            { key: `flags.midi-qol.disadvantage.attack.all`, mode: CONST.ACTIVE_EFFECT_MODES.CUSTOM, value: 1, priority: 20 }]\n\t};\n};\nif (rollvalue == 3) {\n\tsaveType = \"wis\";\n\teffectType=\"incapacitated\";\n\teffectData = {\n\t\tlabel: \"Incapacitated\",\n\t\ticon: \"modules/combat-utility-belt/icons/incapacitated.svg\",\n\t\tflags: { dae: { macroRepeat: \"none\", specialDuration: [\"turnStartSource\"] } },\n\t\torigin: lastArg.uuid,\n\t\tdisabled: false,\n\t\tduration: {seconds: 12, rounds: 1, turns: 1, startRound: gameRound, startTime: game.time.worldTime }\n\t};\n};\nconsole.log(saveType); \n\n//**********************   Cycle through targets and apply saving throws as appropriate   *********************************************;\n\nconst actorD = game.actors.get(lastArg.actor._id);\n//const tokenD = canvas.tokens.get(lastArg.tokenId);\nconst DC = actorD.data.data.attributes.spelldc;\nconsole.log(\"Spell DC: \" +  DC);\n\nlet targets = await lastArg.targets;\n\nfor (let target of targets) {\n\tconsole.log(\"target:\");\n\tconsole.log(target);\n    let findTarget = await canvas.tokens.get(target.id);\n\tconsole.log(\"findTarget:\");\n\tconsole.log(findTarget);\n\t// Check for immunity to specific condition;\n\tlet ciArray = target.actor.data.data.traits.ci.value;\n\tconsole.log(\"ciArray: \");\n\tconsole.log(ciArray);\n\tlet getImmunity = false;\n\tif (ciArray.includes(effectType.toLowerCase())) getImmunity = true;\n\tconsole.log(\"Immunity: \" + getImmunity);\n\tif (getImmunity == false) {\n\t\tlet save = await MidiQOL.socket().executeAsGM(\"rollAbility\", { request: \"save\", targetUuid: target.actor.uuid, ability: saveType});\n\t\tlet saveResult = \"saves\";    \n\t\tif (DC > save.total) {\n\t\t\tsaveResult = \"fails\";\n\t\t\tlet gameRound = game.combat ? game.combat.round : 0;\n\t\t\tlet effect = target.actor.effects.find(i=> i.data.label === game.i18n.localize(effectType));\n\t\t\tconsole.log(effect);\n\t\t\tconsole.log(\"Effect Object\");\n\t\t\t//console.log(target.actor);\n\t\t\tconsole.log(\"Actor Object\");\n\t\t\tif(!effect) await MidiQOL.socket().executeAsGM(\"createEffects\", { actorUuid: target.actor.uuid, effects: [effectData] });\n\t\t};\n\tconsole.log(saveResult + \" Result\");\n\t};\n};",
        },
        "flags": {}
      }
    }
  }
}